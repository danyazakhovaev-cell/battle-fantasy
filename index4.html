<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ë–∏—Ç–≤—ã Fantasy: Online</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root {
            --bg-color: #121212;
            --panel-bg: #1e1e1e;
            --text-color: #e0e0e0;
            --accent: #ff9800;
            --btn-bg: #333;
            --btn-hover: #444;
            --p1-color: #4CAF50; /* Green */
            --p2-color: #2196F3; /* Blue */
        }

        body {
            margin: 0; padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', sans-serif;
            height: 100vh; overflow: hidden; user-select: none;
            display: flex; flex-direction: column; align-items: center;
        }

        /* HEADER */
        header {
            width: 100%; padding: 10px 0; background: #000;
            display: flex; justify-content: center; align-items: center; gap: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5); z-index: 10;
        }
        h1 { margin: 0; font-size: 1.1rem; letter-spacing: 2px; text-transform: uppercase; }

        /* PHASE BAR */
        #phase-bar { display: flex; gap: 5px; background: #222; padding: 5px; border-radius: 20px; }
        .phase-step {
            padding: 4px 12px; border-radius: 15px; font-size: 0.75rem; color: #666;
            background: #151515; border: 1px solid #333; transition: all 0.3s;
        }
        .phase-active { color: #000; background: var(--accent); font-weight: bold; box-shadow: 0 0 8px var(--accent); }

        /* GAME AREA */
        #game-container { display: flex; gap: 20px; margin-top: 20px; position: relative; }
        #canvas-wrapper {
            position: relative; border: 4px solid #444; box-shadow: 0 0 30px rgba(0,0,0,0.8);
        }
        canvas { display: block; background: #252525; cursor: crosshair; }

        /* SIDEBAR */
        #sidebar { width: 300px; height: 600px; display: flex; flex-direction: column; gap: 10px; }
        
        #network-status {
            padding: 10px; background: #2a2a2a; border-radius: 4px; font-size: 0.8rem;
            color: #aaa; text-align: center; border: 1px solid #444;
        }
        .status-online { color: #4CAF50; font-weight: bold; }
        .status-offline { color: #f44336; }

        #info-panel { background: var(--panel-bg); padding: 15px; border-radius: 4px; text-align: center; border: 1px solid #333; }
        #turn-info { font-size: 1.2rem; font-weight: bold; margin-bottom: 5px; }
        #sub-info { font-size: 0.85rem; color: #888; }

        #log-panel {
            flex-grow: 1; background: #000; border: 1px solid #333; padding: 10px;
            overflow-y: auto; font-family: 'Courier New', monospace; font-size: 0.8rem;
        }
        .log-entry { margin-bottom: 4px; border-bottom: 1px solid #222; padding-bottom: 2px; }
        .log-phase { color: var(--accent); font-weight: bold; margin-top: 8px; border-top: 1px dashed #444; padding-top: 4px; }
        .log-hit { color: #ff5252; }
        .log-sys { color: #2196F3; font-style: italic; }

        .action-btn {
            width: 100%; padding: 15px; background: var(--btn-bg); color: white;
            border: none; cursor: pointer; font-weight: bold; text-transform: uppercase;
            border-radius: 4px; transition: 0.2s;
        }
        .action-btn:hover:not(:disabled) { background: var(--btn-hover); }
        .action-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-green { background: #388E3C; }

        /* OVERLAYS */
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.92); z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }

        /* MENU STYLES */
        .menu-box {
            background: #2d2d2d; padding: 30px; border-radius: 8px; border: 1px solid #555;
            text-align: center; width: 350px;
        }
        .menu-btn {
            display: block; width: 100%; padding: 12px; margin: 10px 0;
            background: #444; color: #fff; border: 1px solid #666; cursor: pointer;
            font-size: 1rem; text-transform: uppercase;
        }
        .menu-btn:hover { background: #555; border-color: #fff; }
        
        .faction-select { display: flex; gap: 10px; justify-content: center; margin-bottom: 20px; }
        .f-card { 
            border: 2px solid #444; padding: 10px; cursor: pointer; width: 80px; 
            transition: 0.2s; opacity: 0.6;
        }
        .f-card:hover, .f-card.selected { border-color: var(--accent); opacity: 1; transform: scale(1.1); }
        .f-icon { font-size: 2rem; display: block; margin-bottom: 5px; }

        /* LINK BOX */
        #link-container { display: none; margin-top: 20px; }
        #share-link {
            width: 100%; padding: 8px; background: #111; border: 1px solid #444;
            color: var(--accent); margin-bottom: 10px; font-size: 0.9rem;
        }

        /* DICE */
        #dice-overlay { display: none; background: rgba(0,0,0,0.5); z-index: 200; }
        .dice-box { background: #222; border: 2px solid #fff; padding: 20px; border-radius: 10px; text-align: center; }
        .dice-val { font-size: 4rem; font-weight: bold; color: #fff; margin: 10px 0; }
        
        .tooltip {
            position: absolute; background: rgba(0,0,0,0.9); border: 1px solid #777;
            color: #fff; padding: 5px 10px; font-size: 0.75rem; pointer-events: none;
            display: none; z-index: 50;
        }
    </style>
</head>
<body>

    <header>
        <h1>BF: ONLINE</h1>
        <div id="phase-bar">
            <div id="ph-1" class="phase-step">1. –ú–ê–ù–Å–í–†</div>
            <div id="ph-2" class="phase-step">2. –ë–û–ô</div>
            <div id="ph-3" class="phase-step">3. –°–¢–†–ï–õ–¨–ë–ê</div>
            <div id="ph-4" class="phase-step">4. –ú–ê–ì–ò–Ø</div>
        </div>
    </header>

    <div id="game-container">
        <div id="canvas-wrapper">
            <canvas id="gameCanvas" width="600" height="600"></canvas>
            <div id="tooltip" class="tooltip"></div>

            <div id="menu-screen" class="overlay">
                <div class="menu-box">
                    <h2 style="color:#fff; margin-top:0;">–ë–ò–¢–í–´ FANTASY</h2>
                    <div style="color:#aaa; font-size:0.9rem; margin-bottom:20px;">–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º:</div>
                    
                    <button class="menu-btn" onclick="game.initHotseat()">–ò–ì–†–ê–¢–¨ –° –ë–û–¢–û–ú (–û–§–§–õ–ê–ô–ù)</button>
                    <hr style="border-color:#444; margin: 15px 0;">
                    <button class="menu-btn btn-green" onclick="network.createGame()">–°–û–ó–î–ê–¢–¨ –û–ù–õ–ê–ô–ù –ò–ì–†–£</button>
                    
                    <div id="link-container">
                        <div style="color:var(--accent); font-size:0.8rem; margin-bottom:5px;">–û—Ç–ø—Ä–∞–≤—å —ç—Ç—É —Å—Å—ã–ª–∫—É –¥—Ä—É–≥—É:</div>
                        <input type="text" id="share-link" readonly onclick="this.select()">
                        <div style="font-size:0.8rem; color:#888;">–û–∂–∏–¥–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è...</div>
                    </div>
                </div>
            </div>

            <div id="faction-screen" class="overlay" style="display:none;">
                <div class="menu-box">
                    <h3>–í–´–ë–ï–†–ò–¢–ï –û–¢–†–Ø–î</h3>
                    <div class="faction-select">
                        <div class="f-card" onclick="ui.selectFaction('ORCS', this)">
                            <span class="f-icon">üíÄ</span>–û—Ä–∫–∏
                        </div>
                        <div class="f-card" onclick="ui.selectFaction('ELVES', this)">
                            <span class="f-icon">üßù</span>–≠–ª—å—Ñ—ã
                        </div>
                        <div class="f-card" onclick="ui.selectFaction('DWARVES', this)">
                            <span class="f-icon">üõ°Ô∏è</span>–ì–Ω–æ–º—ã
                        </div>
                    </div>
                    <button id="btn-start-game" class="menu-btn" disabled onclick="game.confirmFaction()">–í –ë–û–ô</button>
                </div>
            </div>

            <div id="dice-overlay" class="overlay">
                <div class="dice-box">
                    <div id="dice-title" style="color:#aaa; font-size:0.9rem;">–ë–†–û–°–û–ö</div>
                    <div id="dice-result" class="dice-val">?</div>
                    <button id="btn-dice" class="action-btn" style="padding:5px 20px;">OK</button>
                </div>
            </div>
        </div>

        <div id="sidebar">
            <div id="network-status">–û—Ñ—Ñ–ª–∞–π–Ω —Ä–µ–∂–∏–º</div>
            <div id="info-panel">
                <div id="turn-info">...</div>
                <div id="sub-info">...</div>
            </div>
            <div id="log-panel"></div>
            <button id="btn-next-phase" class="action-btn" onclick="game.nextPhase()">–°–õ–ï–î. –§–ê–ó–ê</button>
        </div>
    </div>

<script>
/**
 * DATA & CONFIG
 */
const TILE_SIZE = 60;
const GRID_SIZE = 10;
const ICONS = { LEADER:'üëë', MELEE:'‚öîÔ∏è', BOW:'üèπ', AXE:'ü™ì', SHIELD:'üõ°Ô∏è', MACE:'üî®' };
const PHASES = { MANEUVER: 1, MELEE: 2, SHOOT: 3, MAGIC: 4 };
const TEAMS = { HOME: 'home', AWAY: 'away' }; // Home = Left (Host), Away = Right (Client/CPU)

const FACTIONS = {
    ORCS: { name: '–ë–∞–Ω–¥–∞ –ì—Ä–æ–±–∞–≥', color: '#4CAF50', roster: [
        { name: '–õ–µ–≥–∏–æ–Ω–µ—Ä', icon: ICONS.MELEE, p: 2, m: 2, shoot: 0, armor: 1 },
        { name: '–õ–µ–≥–∏–æ–Ω–µ—Ä', icon: ICONS.AXE, p: 2, m: 2, shoot: 0, armor: 1 },
        { name: '–õ–µ–≥–∏–æ–Ω–µ—Ä', icon: ICONS.AXE, p: 2, m: 2, shoot: 0, armor: 1 },
        { name: '–õ—É—á–Ω–∏–∫', icon: ICONS.BOW, p: 1, m: 2, shoot: 1, armor: 1 },
        { name: '–õ–µ–≥–∏–æ–Ω–µ—Ä', icon: ICONS.MACE, p: 2, m: 2, shoot: 0, armor: 1 }
    ]},
    ELVES: { name: '–≠–ª—å—Ñ—ã', color: '#FFD700', roster: [
        { name: '–ö–æ–º–∞–Ω–¥–æ—Ä', icon: ICONS.LEADER, p: 3, m: 1, shoot: 0, armor: 3 },
        { name: '–ì–≤–∞—Ä–¥–µ–µ—Ü', icon: ICONS.SHIELD, p: 3, m: 1, shoot: 0, armor: 3 },
        { name: '–ê–ª–µ–±–∞—Ä–¥–∏—Å—Ç', icon: ICONS.AXE, p: 3, m: 2, shoot: 0, armor: 2 },
        { name: '–ì–≤–∞—Ä–¥–µ–µ—Ü', icon: ICONS.MELEE, p: 3, m: 1, shoot: 0, armor: 3 },
        { name: '–°—Ç—Ä–µ–ª–æ–∫', icon: ICONS.BOW, p: 1, m: 2, shoot: 2, armor: 2 }
    ]},
    DWARVES: { name: '–ì–Ω–æ–º—ã', color: '#2196F3', roster: [
        { name: '–í–æ–∂–¥—å', icon: ICONS.LEADER, p: 3, m: 2, shoot: 0, armor: 2 },
        { name: '–ë–µ—Ä—Å–µ—Ä–∫', icon: ICONS.MACE, p: 2, m: 2, shoot: 0, armor: 2 },
        { name: '–ë–µ—Ä—Å–µ—Ä–∫', icon: ICONS.AXE, p: 2, m: 2, shoot: 0, armor: 2 },
        { name: '–í–æ–∏–Ω', icon: ICONS.SHIELD, p: 2, m: 2, shoot: 0, armor: 2 },
        { name: '–í–æ–∏–Ω', icon: ICONS.MACE, p: 2, m: 2, shoot: 0, armor: 2 }
    ]}
};

/**
 * NETWORK MANAGER (PeerJS)
 * Handles P2P Connection
 */
class NetworkManager {
    constructor() {
        this.peer = null;
        this.conn = null;
        this.isHost = false;
        this.isConnected = false;
        this.myId = null;
    }

    init() {
        // –°–æ–∑–¥–∞–µ–º Peer ID (—Å–ª—É—á–∞–π–Ω–∞—è —Å—Ç—Ä–æ–∫–∞)
        this.peer = new Peer(null, { debug: 2 });

        this.peer.on('open', (id) => {
            this.myId = id;
            console.log('My ID: ' + id);
            
            // –ï—Å–ª–∏ –≤ URL –µ—Å—Ç—å ID, –∑–Ω–∞—á–∏—Ç –º—ã –ö–ª–∏–µ–Ω—Ç –∏ –ø—ã—Ç–∞–µ–º—Å—è –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è
            const hash = window.location.hash.replace('#', '');
            if (hash) {
                this.connectToPeer(hash);
            }
        });

        // –ï—Å–ª–∏ –∫—Ç–æ-—Ç–æ –ø–æ–¥–∫–ª—é—á–∞–µ—Ç—Å—è –∫ –Ω–∞–º (–º—ã –•–æ—Å—Ç)
        this.peer.on('connection', (c) => {
            this.handleConnection(c);
        });
    }

    createGame() {
        this.isHost = true;
        document.getElementById('link-container').style.display = 'block';
        const link = window.location.origin + window.location.pathname + '#' + this.myId;
        document.getElementById('share-link').value = link;
        
        // Host is waiting...
    }

    connectToPeer(hostId) {
        this.isHost = false;
        // –ó–∞–∫—Ä—ã–≤–∞–µ–º –º–µ–Ω—é, –∂–¥–µ–º –∫–æ–Ω–Ω–µ–∫—Ç–∞
        document.getElementById('menu-screen').style.display = 'none';
        ui.log("–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Å–µ—Ä–≤–µ—Ä—É...", "log-sys");
        
        const conn = this.peer.connect(hostId);
        this.handleConnection(conn);
    }

    handleConnection(c) {
        this.conn = c;
        
        this.conn.on('open', () => {
            this.isConnected = true;
            document.getElementById('network-status').innerHTML = '<span class="status-online">‚óè ONLINE</span>';
            document.getElementById('network-status').style.borderColor = '#4CAF50';
            
            if (this.isHost) {
                // –ï—Å–ª–∏ –º—ã –•–æ—Å—Ç, –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –≤—ã–±–æ—Ä—É —Ñ—Ä–∞–∫—Ü–∏–∏
                ui.log("–ò–≥—Ä–æ–∫ –ø–æ–¥–∫–ª—é—á–∏–ª—Å—è!", "log-sys");
                document.getElementById('menu-screen').style.display = 'none';
                document.getElementById('faction-screen').style.display = 'flex';
            } else {
                ui.log("–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ!", "log-sys");
                // –ö–ª–∏–µ–Ω—Ç –∂–¥–µ—Ç, –ø–æ–∫–∞ –•–æ—Å—Ç –≤—ã–±–µ—Ä–µ—Ç –∏ –Ω–∞—á–Ω–µ—Ç—Å—è –∏–≥—Ä–∞
                // –ù–æ –¥–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã: –æ–±–∞ –≤—ã–±–∏—Ä–∞—é—Ç —Ñ—Ä–∞–∫—Ü–∏—é
                document.getElementById('faction-screen').style.display = 'flex';
            }
        });

        this.conn.on('data', (data) => {
            game.handleNetworkData(data);
        });

        this.conn.on('close', () => {
            alert("–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Ä–∞–∑–æ—Ä–≤–∞–Ω–æ");
            location.reload();
        });
    }

    send(data) {
        if (this.isConnected && this.conn) {
            this.conn.send(data);
        }
    }
}

/**
 * UI MANAGER
 */
const ui = {
    selectedFactionKey: null,
    
    selectFaction: (key, el) => {
        ui.selectedFactionKey = key;
        document.querySelectorAll('.f-card').forEach(c => c.classList.remove('selected'));
        el.classList.add('selected');
        document.getElementById('btn-start-game').disabled = false;
    },

    log: (msg, type='') => {
        const p = document.getElementById('log-panel');
        const div = document.createElement('div');
        div.className = `log-entry ${type}`;
        div.innerText = msg;
        p.appendChild(div);
        p.scrollTop = p.scrollHeight;
    },

    update: (turnTeam, phase, isMyTurn) => {
        // Phase bar
        for(let i=1; i<=4; i++) document.getElementById(`ph-${i}`).className = 'phase-step';
        document.getElementById(`ph-${phase}`).className = 'phase-step phase-active';

        // Text
        const tInfo = document.getElementById('turn-info');
        const sInfo = document.getElementById('sub-info');
        const btn = document.getElementById('btn-next-phase');

        if (isMyTurn) {
            tInfo.innerText = "–í–ê–® –•–û–î";
            tInfo.style.color = "#4CAF50";
            btn.disabled = false;
        } else {
            tInfo.innerText = "–•–û–î –ü–†–û–¢–ò–í–ù–ò–ö–ê";
            tInfo.style.color = "#ff5252";
            btn.disabled = true;
        }

        const phases = ["", "–ú–ê–ù–Å–í–†: –î–≤–∏–≥–∞–π—Ç–µ —é–Ω–∏—Ç–æ–≤", "–ë–û–ô: –ê—Ç–∞–∫—É–π—Ç–µ —Å–æ—Å–µ–¥–Ω–∏—Ö", "–°–¢–†–ï–õ–¨–ë–ê: –î–∏—Å—Ç–∞–Ω—Ü. –∞—Ç–∞–∫–∞", "–ú–ê–ì–ò–Ø: –°–ª—É—á–∞–π–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç"];
        sInfo.innerText = phases[phase];
    }
};

/**
 * GAME ENGINE
 */
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.units = [];
        this.selectedUnit = null;
        
        // State
        this.currentTurn = TEAMS.HOME; // Home always starts
        this.currentPhase = PHASES.MANEUVER;
        this.myTeam = null; // 'home' or 'away'
        this.isOnline = false;
        this.shotsLeft = 0;
        
        // Listeners
        this.canvas.addEventListener('mousedown', e => this.handleClick(e));
        this.canvas.addEventListener('mousemove', e => this.handleHover(e));
        
        // Loop
        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }

    initHotseat() {
        this.isOnline = false;
        this.myTeam = TEAMS.HOME; // In hotseat, human controls Home, CPU controls Away
        document.getElementById('menu-screen').style.display = 'none';
        document.getElementById('faction-screen').style.display = 'flex';
    }

    confirmFaction() {
        const myFactionKey = ui.selectedFactionKey;
        // Random enemy faction
        const keys = Object.keys(FACTIONS).filter(k => k !== myFactionKey);
        const enemyFactionKey = keys[Math.floor(Math.random() * keys.length)];

        if (this.isOnline) {
            // –í –æ–Ω–ª–∞–π–Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–≤–æ–π –≤—ã–±–æ—Ä —Å–æ–ø–µ—Ä–Ω–∏–∫—É
            network.send({ type: 'FACTION_SELECT', key: myFactionKey });
            this.myFactionData = FACTIONS[myFactionKey];
            document.getElementById('faction-screen').innerHTML = "<div class='menu-box'><h3>–û–∂–∏–¥–∞–Ω–∏–µ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞...</h3></div>";
            
            // –ï—Å–ª–∏ –º—ã –∫–ª–∏–µ–Ω—Ç –∏ —É–∂–µ –ø–æ–ª—É—á–∏–ª–∏ –¥–∞–Ω–Ω—ã–µ –æ—Ç —Ö–æ—Å—Ç–∞ (–∏–ª–∏ –Ω–∞–æ–±–æ—Ä–æ—Ç)
            if (this.enemyFactionData) {
                this.startOnlineGame();
            }
        } else {
            // Offline
            this.spawnArmy(FACTIONS[myFactionKey], TEAMS.HOME);
            this.spawnArmy(FACTIONS[enemyFactionKey], TEAMS.AWAY);
            document.getElementById('faction-screen').style.display = 'none';
            this.startTurn(TEAMS.HOME);
            ui.log("–†–µ–∂–∏–º: –ò–≥—Ä–æ–∫ –ø—Ä–æ—Ç–∏–≤ –ë–æ—Ç–∞", "log-sys");
        }
    }

    handleNetworkData(data) {
        if (data.type === 'FACTION_SELECT') {
            this.enemyFactionData = FACTIONS[data.key];
            if (this.myFactionData) {
                this.startOnlineGame();
            }
        }
        else if (data.type === 'ACTION') {
            this.processRemoteAction(data);
        }
    }

    startOnlineGame() {
        document.getElementById('faction-screen').style.display = 'none';
        this.isOnline = true;
        
        // Determine teams based on who is host
        if (network.isHost) {
            this.myTeam = TEAMS.HOME;
            this.spawnArmy(this.myFactionData, TEAMS.HOME);
            this.spawnArmy(this.enemyFactionData, TEAMS.AWAY);
        } else {
            this.myTeam = TEAMS.AWAY;
            this.spawnArmy(this.enemyFactionData, TEAMS.HOME); // Host is Home
            this.spawnArmy(this.myFactionData, TEAMS.AWAY); // Client is Away
        }

        ui.log("–°–µ—Ç–µ–≤–∞—è –∏–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å!", "log-sys");
        this.startTurn(TEAMS.HOME);
    }

    spawnArmy(faction, team) {
        const startX = (team === TEAMS.HOME) ? 0 : 9;
        faction.roster.forEach((stats, i) => {
            this.units.push({
                ...stats,
                id: team + '_' + i,
                team: team,
                x: startX,
                y: i * 2,
                hp: 1,
                maxMove: 1 + stats.m,
                hasMoved: false, hasAttacked: false,
                color: faction.color
            });
        });
    }

    // --- TURN LOGIC ---

    get isMyTurn() {
        return this.currentTurn === this.myTeam;
    }

    startTurn(team) {
        this.currentTurn = team;
        this.currentPhase = PHASES.MANEUVER;
        this.units.forEach(u => { u.hasMoved = false; u.hasAttacked = false; });
        
        ui.update(this.currentTurn, this.currentPhase, this.isMyTurn);
        
        if (team === TEAMS.HOME) ui.log("--- –•–û–î: –ò–ì–†–û–ö 1 ---", "log-phase");
        else ui.log("--- –•–û–î: –ò–ì–†–û–ö 2 ---", "log-phase");

        // CPU Logic if offline
        if (!this.isOnline && team === TEAMS.AWAY) {
            setTimeout(() => this.cpuAiTurn(), 1000);
        }
    }

    nextPhase() {
        if (!this.isMyTurn) return; // Anti-cheat click

        let next = this.currentPhase + 1;
        let eventData = { type: 'PHASE_CHANGE', phase: next };

        // Logic for Shoot/Magic preparation
        if (next === PHASES.SHOOT) {
            const shooters = this.units.filter(u => u.team === this.currentTurn && u.shoot > 0);
            if (shooters.length === 0) {
                ui.log("–ù–µ—Ç —Å—Ç—Ä–µ–ª–∫–æ–≤. –ü—Ä–æ–ø—É—Å–∫ —Ñ–∞–∑—ã.", "log-sys");
                this.currentPhase = PHASES.MAGIC; // Skip
                next = PHASES.MAGIC;
                eventData.phase = next;
            } else {
                const roll = Math.floor(Math.random()*6)+1;
                this.shotsLeft = roll;
                eventData.roll = roll;
                ui.log(`–ë–æ–µ–∑–∞–ø–∞—Å (D6): ${roll} –≤—ã—Å—Ç—Ä–µ–ª–æ–≤`);
            }
        }

        if (next > PHASES.MAGIC) {
            this.sendAction({ type: 'END_TURN' });
            this.endTurn();
        } else {
            this.sendAction(eventData);
            this.applyPhaseChange(next, eventData.roll);
        }
    }

    applyPhaseChange(phase, rollVal) {
        this.currentPhase = phase;
        this.selectedUnit = null;
        if (phase === PHASES.SHOOT && rollVal) this.shotsLeft = rollVal;
        
        if (phase === PHASES.MAGIC) {
            this.resolveMagic(); // Auto resolve magic
        }
        
        ui.update(this.currentTurn, this.currentPhase, this.isMyTurn);
    }

    endTurn() {
        const nextTeam = (this.currentTurn === TEAMS.HOME) ? TEAMS.AWAY : TEAMS.HOME;
        this.startTurn(nextTeam);
    }

    // --- ACTIONS ---

    handleClick(e) {
        if (!this.isMyTurn) return;
        
        const rect = this.canvas.getBoundingClientRect();
        const x = Math.floor((e.clientX - rect.left) / TILE_SIZE);
        const y = Math.floor((e.clientY - rect.top) / TILE_SIZE);
        
        const clickedUnit = this.units.find(u => u.x === x && u.y === y);

        // SELECT
        if (clickedUnit && clickedUnit.team === this.myTeam) {
            // Check restrictions
            if (this.currentPhase === PHASES.MANEUVER && clickedUnit.hasMoved) return;
            if ((this.currentPhase === PHASES.MELEE || this.currentPhase === PHASES.SHOOT) && clickedUnit.hasAttacked) return;
            if (this.currentPhase === PHASES.SHOOT && clickedUnit.shoot === 0) return;
            
            this.selectedUnit = clickedUnit;
            return;
        }

        // MOVE
        if (this.selectedUnit && !clickedUnit && this.currentPhase === PHASES.MANEUVER) {
            if (this.isValidMove(this.selectedUnit, x, y)) {
                this.executeMove(this.selectedUnit.id, x, y);
                this.sendAction({ type: 'MOVE', uId: this.selectedUnit.id, x: x, y: y });
            }
        }

        // ATTACK
        if (this.selectedUnit && clickedUnit && clickedUnit.team !== this.myTeam) {
            const attackType = (this.currentPhase === PHASES.MELEE) ? 'Melee' : 'Shoot';
            if (this.isValidAttack(this.selectedUnit, clickedUnit, attackType)) {
                
                // Roll dice
                const roll = Math.floor(Math.random()*6)+1;
                this.executeAttack(this.selectedUnit.id, clickedUnit.id, attackType, roll);
                this.sendAction({ type: 'ATTACK', uId: this.selectedUnit.id, tId: clickedUnit.id, aType: attackType, roll: roll });
            }
        }
    }

    // --- GAMEPLAY EXECUTION (Shared Local/Network) ---

    executeMove(uId, x, y) {
        const u = this.units.find(u => u.id === uId);
        if (u) {
            u.x = x; u.y = y;
            u.hasMoved = true;
            this.selectedUnit = null;
        }
    }

    executeAttack(uId, tId, type, roll) {
        const att = this.units.find(u => u.id === uId);
        const def = this.units.find(u => u.id === tId);
        if (!att || !def) return;

        this.showDice(roll); // Visual

        const bonus = (type === 'Melee') ? att.p : att.shoot;
        const total = roll + bonus;
        const defense = def.armor + 3;
        
        let msg = `${att.name} (${type}) [${roll}+${bonus}=${total}] vs –ó–∞—â.${defense}`;
        
        if (total >= defense) {
            ui.log(msg + " > –£–ë–ò–¢!", "log-hit");
            this.units = this.units.filter(u => u.id !== tId); // Kill
            this.checkWin();
        } else {
            ui.log(msg + " > –ü—Ä–æ–º–∞—Ö.");
        }

        att.hasAttacked = true;
        if (type === 'Shoot') {
            this.shotsLeft--;
            if (this.isMyTurn) ui.update(this.currentTurn, this.currentPhase, true);
        }
        this.selectedUnit = null;
    }

    resolveMagic() {
        if (!this.isMyTurn && this.isOnline) return; // Only active player rolls magic

        const roll = Math.floor(Math.random()*6)+1;
        this.executeMagic(roll);
        if (this.isOnline) this.sendAction({ type: 'MAGIC', roll: roll });
    }

    executeMagic(roll) {
        let txt = `–ú–∞–≥–∏—è (Roll ${roll}): `;
        if (roll === 1) txt += "–ü—Ä–æ–≤–∞–ª! (–í–∞—à —Ö–æ–¥ –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è –Ω–µ—É–¥–∞—á–µ–π)";
        else if (roll === 6) txt += "–ë–ª–∞–≥–æ—Å–ª–æ–≤–µ–Ω–∏–µ! (–Æ–Ω–∏—Ç—ã –≤–æ–æ–¥—É—à–µ–≤–ª–µ–Ω—ã)";
        else txt += "–í–µ—Ç—Ä–∞ –º–∞–≥–∏–∏ —Å–ø–æ–∫–æ–π–Ω—ã.";
        ui.log(txt, "log-sys");
        
        // Auto end turn after delay
        setTimeout(() => {
            if (this.isMyTurn) {
                this.sendAction({ type: 'END_TURN' });
                this.endTurn();
            }
        }, 2000);
    }

    // --- NETWORKING HELPERS ---

    sendAction(payload) {
        if (this.isOnline) {
            network.send({ type: 'ACTION', ...payload });
        }
    }

    processRemoteAction(data) {
        // Apply opponent's actions
        if (data.type === 'MOVE') this.executeMove(data.uId, data.x, data.y);
        if (data.type === 'ATTACK') this.executeAttack(data.uId, data.tId, data.aType, data.roll);
        if (data.type === 'PHASE_CHANGE') this.applyPhaseChange(data.phase, data.roll);
        if (data.type === 'MAGIC') this.executeMagic(data.roll);
        if (data.type === 'END_TURN') this.endTurn();
    }

    // --- RULES & UTILS ---

    isValidMove(u, tx, ty) {
        if (Math.abs(u.x - tx) + Math.abs(u.y - ty) > u.maxMove) return false; // Simple Manhattan dist check approx
        // BFS pathfinding is better but keeping simple for brevity in one file
        // Let's do a simple check: is free?
        if (this.units.some(other => other.x === tx && other.y === ty)) return false;
        // Check dist
        return this.getDistance(u.x, u.y, tx, ty) <= u.maxMove;
    }

    isValidAttack(u, t, type) {
        const d = Math.max(Math.abs(u.x - t.x), Math.abs(u.y - t.y)); // Chebyshev
        if (type === 'Melee') return d === 1;
        if (type === 'Shoot') return d > 1 && d <= 8 && this.shotsLeft > 0;
        return false;
    }
    
    getDistance(x1,y1,x2,y2) {
        // Pathfinding BFS for accurate move distance
        let q = [{x:x1, y:y1, d:0}];
        let visited = new Set([x1+','+y1]);
        while(q.length) {
            let c = q.shift();
            if (c.x === x2 && c.y === y2) return c.d;
            if (c.d >= 10) continue;
            [[0,1],[0,-1],[1,0],[-1,0]].forEach(dir => {
                let nx=c.x+dir[0], ny=c.y+dir[1];
                if (nx>=0 && nx<GRID_SIZE && ny>=0 && ny<GRID_SIZE && !visited.has(nx+','+ny)) {
                    if (!this.units.some(u => u.x === nx && u.y === ny)) {
                        visited.add(nx+','+ny);
                        q.push({x:nx, y:ny, d:c.d+1});
                    } else if (nx===x2 && ny===y2) {
                        q.push({x:nx, y:ny, d:c.d+1}); // Target occupied but reachable for calculation
                    }
                }
            });
        }
        return 99;
    }

    checkWin() {
        const homeAlive = this.units.some(u => u.team === TEAMS.HOME);
        const awayAlive = this.units.some(u => u.team === TEAMS.AWAY);
        if (!homeAlive || !awayAlive) {
            setTimeout(() => {
                alert("–ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê!");
                location.reload();
            }, 500);
        }
    }

    showDice(val) {
        const el = document.getElementById('dice-overlay');
        const res = document.getElementById('dice-result');
        el.style.display = 'flex';
        res.innerText = val;
        setTimeout(() => el.style.display = 'none', 1000);
    }

    // --- CPU AI (Legacy/Offline) ---
    async cpuAiTurn() {
        // Simple simplified AI for offline test
        const cpuUnits = this.units.filter(u => u.team === TEAMS.AWAY);
        if (cpuUnits.length === 0) return;

        // 1. Move
        for (let u of cpuUnits) {
            const enemies = this.units.filter(e => e.team === TEAMS.HOME);
            if (!enemies.length) break;
            const target = enemies[0];
            
            // Try move closer
            if (this.getDistance(u.x, u.y, target.x, target.y) > 1) {
                // dumb move
                let mx = u.x + Math.sign(target.x - u.x);
                let my = u.y + Math.sign(target.y - u.y);
                if (!this.units.some(o => o.x === mx && o.y === my)) {
                    this.executeMove(u.id, mx, my);
                    await new Promise(r => setTimeout(r, 300));
                }
            }
        }
        this.currentPhase = PHASES.MELEE; ui.update(TEAMS.AWAY, 2, false);
        
        // 2. Attack
        for (let u of cpuUnits) {
            const enemies = this.units.filter(e => e.team === TEAMS.HOME);
            for (let e of enemies) {
                if (this.isValidAttack(u, e, 'Melee')) {
                    this.executeAttack(u.id, e.id, 'Melee', Math.floor(Math.random()*6)+1);
                    await new Promise(r => setTimeout(r, 500));
                }
            }
        }

        this.endTurn();
    }

    // --- RENDER ---
    draw() {
        this.ctx.fillStyle = '#252525';
        this.ctx.fillRect(0,0,600,600);
        
        // Grid
        this.ctx.strokeStyle = '#333';
        for(let i=0; i<=GRID_SIZE; i++) {
            this.ctx.beginPath(); this.ctx.moveTo(i*TILE_SIZE,0); this.ctx.lineTo(i*TILE_SIZE,600); this.ctx.stroke();
            this.ctx.beginPath(); this.ctx.moveTo(0,i*TILE_SIZE); this.ctx.lineTo(600,i*TILE_SIZE); this.ctx.stroke();
        }

        // Highlights
        if (this.selectedUnit) {
            this.ctx.fillStyle = 'rgba(255,255,255,0.1)';
            this.ctx.fillRect(this.selectedUnit.x*TILE_SIZE, this.selectedUnit.y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
            
            // Range
            if (this.currentPhase === PHASES.MANEUVER) {
                this.ctx.fillStyle = 'rgba(76, 175, 80, 0.2)';
                for(let x=0; x<GRID_SIZE; x++) for(let y=0; y<GRID_SIZE; y++) {
                    if (this.isValidMove(this.selectedUnit, x, y)) {
                        this.ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
            }
        }

        // Units
        this.units.forEach(u => {
            const cx = u.x*TILE_SIZE+30;
            const cy = u.y*TILE_SIZE+30;
            
            this.ctx.beginPath(); this.ctx.arc(cx, cy, 24, 0, Math.PI*2);
            this.ctx.fillStyle = u.color; this.ctx.fill();
            
            this.ctx.lineWidth = 2;
            this.ctx.strokeStyle = (u.team === TEAMS.HOME) ? '#fff' : '#000';
            this.ctx.stroke();

            // Armor
            this.ctx.beginPath(); this.ctx.arc(cx, cy, 28, 0, Math.PI*2);
            this.ctx.lineWidth = u.armor; this.ctx.strokeStyle = 'gold'; this.ctx.stroke();

            // Icon
            this.ctx.fillStyle = '#fff'; this.ctx.font = '24px serif';
            this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle';
            this.ctx.fillText(u.icon, cx, cy+2);

            // Grey out
            let spent = (this.currentPhase === PHASES.MANEUVER && u.hasMoved) ||
                        ((this.currentPhase === PHASES.MELEE || this.currentPhase === PHASES.SHOOT) && u.hasAttacked);
            if (spent) {
                this.ctx.fillStyle = 'rgba(0,0,0,0.6)';
                this.ctx.beginPath(); this.ctx.arc(cx,cy,24,0,Math.PI*2); this.ctx.fill();
            }
        });
    }

    loop() {
        this.draw();
        requestAnimationFrame(this.loop);
    }
}

// INIT
const network = new NetworkManager();
const game = new Game();
network.init(); // Start looking for ID

</script>
</body>
</html>